### 问题描述：

#### 一个数组中只有两个数字是出现一次，其他所有数字都出现了两次，找出这两个数字，编程实现。

#### 问题思路：

（1）先将数组元素整体异或；

（2）将异或结果从最低位找第一个出现的1；

（3）遍历数组将其分为A、B组；

（4）对A、B组分别进行异或。

```c
#include<stdio.h>
#include<windows.h>
#include<assert.h>
void findTwoNumber(int *arr, int sz)
{
	assert(arr);
	assert(sz > 0);
	int n = arr[0];//数组异或最好不要引入新变量，因不知道最终结果是引入量还是最终结果，容易有歧义，故推荐直接将结果初始化为数组元素，一般为首元素
	int i = 1;//注意数组异或结果若初始化为首元素，则必须从数组第二个元素开始异或（下文会讲解若从首元素开始异或的错误现象）
	int flag = 1;
	int b1 = 0;//数组异或在不方便定义数组元素时，也可异或为0，因0与任何元素异或都是元素本身，无歧义
	int b2 = 0;
	for (; i < sz; i++)//数组整体异或
	{
		n ^= arr[i];
	}
	while (!(n&flag))//找到第一个出现的1
	{
		flag <<= 1;
	}
	for (i = 0; i < sz; i++)
	{
		if (flag&arr[i])
		{
			//A
			b1 ^= arr[i];
		}
		else
		{
			//B
			b2 ^= arr[i];
		}
	}
	printf("%d %d\n", b1, b2);
}

int main()
{
	int arr[] = { 1,2,3,4,5,6,1,5,2,3 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	findTwoNumber(arr, sz);
	system("pause");
	return 0;
}
```

![1](C:\Users\14665\source\repos\一个数组只有两个数字单独出现一次\1.png)

#### 详细分析：

![2](C:\Users\14665\source\repos\一个数组只有两个数字单独出现一次\2.png)

#### 易错点：

##### （1）若省略整体异或、从最低位找异或结果第一个出现的1的两个步骤，程序还正确吗？

答案是当两个单独出现数字为一奇一偶时可正常使用，但若两个数字为两个奇数或者两个偶数时，便会出现错误。**也就是说此程序是错误的。**

我们来验证一下：

##### 一奇一偶输出正常：

![3](C:\Users\14665\source\repos\一个数组只有两个数字单独出现一次\3.png)

##### 两个偶数输出错误：

![4](C:\Users\14665\source\repos\一个数组只有两个数字单独出现一次\4.png)

**原因很简单，若直接拿1&数组元素进行分组的话，flag检测的永远是数组元素最低比特位是否为0，为0的一组，为1的另外一组，可当两个单独出现数字均为偶数或奇数时就会被分到一组，此时输出错误。**

**（2）第一步数组元素异或结果初始化为数组首元素时，若遍历数组时，从数组首元素开始时，会出现错误。**

![5](C:\Users\14665\source\repos\一个数组只有两个数字单独出现一次\5.png)

**这个易错点的原因是从首元素开始异或，会出现前面数组元素异或时形成与单独出现数字相同的数字，此时再异或即单独数字会以成对出现对待，结果出现偏差。**

