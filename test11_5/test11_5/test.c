#include<stdio.h>
#include<stdlib.h>
int main()
{
	int n = 9;
	float *pFloat = (float*)&n;
	printf("n的值为:%d\n", n);
	printf("pFloat的值为:%f\n", *pFloat);
	*pFloat = 9.0;
	printf("n的值为:%d\n", n);
	printf("pFloat的值为:%f\n", *pFloat);
	system("pause");
	return 0;
}

//n=9时,内存中存储的二进制为0000 0000 0000 0000 0000 0000 0000 1001,输出为9
//取地址n强制转换为float型，即为0 00000000 00000000000000000001001
//S=0，M=00000000，E为00000000000000000001001
//故在输出时为0.000000

//*pFloat = 9.0
//S=0、M=1.001、E=3
//二进制中存储为
//0 10000010 00100000000000000000000
//以%d输出时二进制为 0100 0001 0001 0000 0000 0000 0000 0000
//输出结果为1091567616
//以%f输出结果为9.000000





//int main()
//{
//	float a = 10.0;
//	//首先对于M，因二进制中有效数字的范围为大于等于1小于2，也就是说它恒为1.X，故在存储时可直接存储小数点后的数字即可（小数点无法存储）。
//	//这种方法的好处是可节省一位有效空间。
//	//以32位float为例，将第一位1舍掉后，相当于可存储24位有效数字。
//
//	//对于E，首先，国际规定其为无符号整数，在浮点数内存存储中范围为（0-255）。
//	//但实际上指数可为正为负为零，八个比特位范围为（-127-127），那要怎么样表示呢？
//	//规定存储时，指数E必须需要先+127（中间值，顾名思义为0-255的中间值，使实际E的值负数正数在0的左右个数基本相等）再存储。
//	//所以当内存中E处存储的为130的二进制时，实际上指数E=3;存储的为120的二进制时，实际上指数E=-7。
//	//这样的好处是转化后存入内存中的地址均为正数，不用考虑符号可直接运算，取出时再减去127即可。
//	//（1）E不全为1不全为0
//	//此情况为E的一般情况，存储时按照上述步骤存储即可。
//	//取出时需从内存中获取S、M、E的值，S可直接读取，E的值需先减去127再转为十进制，M需加先"1."再读取M处二进制。最后带回公式得到数据二进制序列。
//	//（2）E全为1
//	//当E存储的二进制为全1时，实际上指数为128，即需要求取2的128次方，此时数字已经非常大。
//	//所以在规定中为当S=0时，数据为正值，此时为float型所能定义的最大值；相反，S=-1时，代表最小值。
//	//故此时代表的不是一个具体的值而是一个范围。
//	//(3)E为全0
//	//当E存储的二进制全为0时，实际上指数为-127，即需要求取2的-127次方，此时数字已经非常小。
//	//当S=0时，数据为正数，此时表示从正轴无限接近0；S=-1时，代表从负轴无限接近0.故此时也表示的是一段距离。
//	//故在规定中认为当E在内存中存储的二进制为全0时，直接认为此数为数字0。（此时不看S、M的值）
//
//
//	
//	//故一开始float a=10.0在内存中存储的结果为 0 10000010 01000000000000000000000 
//
//
//
//
//
//
//
//
//
//
//
//	//int a=10的二进制为0000 0000 0000 0000 0000 0000 0000 1010
//	//float a=10.0的二进制为1.010*2^3
//	//根据国际标准规定:float存储时满足以下公式：(-1)^S*M*2^E
//	//1.(-1)^S表示符号位，当S=0时，数据为正数；S=1时，数据为负数；
//	//2.M代表有效数字，范围为（i>=1&&i<2）;
//	//3.2^E代表指数位。
//	//由float a=10.0的二进制可得出S=0,M=1.010,E=3。
//	//国际规定，对于32位的浮点数在内存中存储，最高位为符号位（S），接着八位为指数位（E），剩下的为有效数位（M）.
//	//又因M的值总是为1.X,故在内存中存储时只需存储小数点后边的有效数字即可（从左到右），所以实际上有效数字可为24位。
//	//故float a=10.0在内存中存储的结果为 0 10000010 01000000000000000000000 
//	system("pause");
//	return 0;
//}


